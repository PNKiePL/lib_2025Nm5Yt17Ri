#pragma once
#ifndef 数字格式_H 
#define 数字格式_H

#include<E:\lib\头文件 c++.h>
//#include<E:\lib\cmd.h>/**/

//>数字每N位分隔 \ vector<类型>
/*使用方法:
coutvec(v);
*/
template <typename 类型, int 数字N>
class 数N分 { /*////2023年6月3日*/
public:
	类型 N位个数 = 0, N位个数_有数值 = 1, _2N位个数 = 0, N位数个数, _2N位数个数; //>N位个数= >已进位的N位数个体 \ N位个数_有数值= 有数值的N位数个体 \ N位个数_有数值= N位个数+1;
	vector<类型>计数; //>[0] 不用, 从[1]开始
	int 十 = 10, 一百 = 100, 一千 = 1000, 一万 = 10000, 十万 = 100000, 百万 = 1000000, 千万 = 10000000, 一亿 = 100000000;
	int 序号_第一个n = 1;/*有效的元素`的开始点*/
public:
	数N分() { //并不会`每次用函数前都运行
		//*cout << std::format("Class数{}分\n", 数字N);
		计数.assign(2, 0);
		初始化();
	}
public:
	/**///▬!主要功能`这次直观了▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	/*区分主要功能`附加功能*/
	/*逻辑是一条直线,乱放=我看不懂*/
	auto 初始化() {
		N位个数_有数值 = 1;
		N位个数 = 0;
	}
	/*修正`有几个`N位数*/
	auto N位个数初始化(vector<类型>& vec) { //标记`有数值的
		for (size_t i = 1; i < 14; i++) {
			if (i < vec.size()) { //if vec[i]=v的元素
				if (vec[i] > 0) {
					/*元素`有数值*/
					N位个数_有数值 = i;
				}/*if`2*/
			}/*if*/
		}/*for*/
		/*实际`个数*/
		N位个数 = N位个数_有数值 - 1; //一般用这个, 不用 N位个数_有数值, 那为什么要有两个？
	}
	//▬1▬功能▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	///2023年7月24日
	//todo 将来有了旁白, 再优化
	///2023年7月25日
	//完成todo 不进位的 拼接的函数
  /*ret数字位数,有几位,有几个字*/
	类型 ret整数位数(类型 uu) {
		int 位数 = 1;
		while (uu >= 10) {
			uu /= 10;
			位数 += 1;
		}
		///cout <<"uu= " << uu;
		///cout << ", 位数= " << 位数;
		///cout << '\n';
		return 位数;
	}/*类型*/
	类型 ret数字有几位(类型 uu) {
		return ret整数位数(uu);
	}/*类型*/
	/**///▬1▬这几个是`连着的▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	//>零件 \ cout \ cout到cmd
	auto 补充0(vector<类型>& vec, 类型 N位数序号) { //>如果是n位数, 显示N-n个0
		类型* vecdatap = vec.data(); vector< 类型>* vecp = &vec;
		//>左边有数字, 中间+0
		类型 N位数序号位置上的位数n = ret整数位数(vec[N位数序号]); //to_string(vec[N位数序号]).size();
		//左边的N位数有数字, 才需要+0
		if (N位个数 >= N位数序号
			&& N位数序号 < vec.size()) { //&& (N位数序号位置上的位数n >= 0)
			类型 _0的个数 = 数字N - N位数序号位置上的位数n;
			///cout << "_0的个数= " << _0的个数;
			///cout << '\n';
			if (_0的个数 >= 0
				&& _0的个数 <= 数字N) { //case(负数): 会一直循环 
				//输出'0'
				for (size_t i = 0; i < _0的个数; i++) {
					///cout << "N位数序号= " << N位数序号;
					///cout << '\n';
					cout << "0";
				}
			}
		}
		vecdatap = nullptr; vecp = nullptr;
	}
	auto 进位(vector<类型>& vec, 类型 N位数序号) {
		类型* vecdatap = vec.data(); vector< 类型>* vecp = &vec;
		//超过N位数-->进位
		// >if vec[n]有数值-->
		if (N位数序号 <= N位个数_有数值) { //N位个数_有数值< vec.size \ size位置不一定用过, 会一直pushback
			///if (N位数序号 < vec.size()) 
			//> if N位数序号< size-->进位 / = size-->push_back(0)
			if (N位数序号 + 1 == vec.size()) { //对应n, n+1		
				///cout << N位数序号 + 1 << "位置增加0 "; //N位数序号= n= 序号
				///cout << '\n';
				//vec.resize(N位个数_有数值 + 3, 0);
				vec.push_back(0); //新增一个序号
			}
			//>if N位数序号> size-->N位置没内容-->忽略
			if (N位数序号 < vec.size()) {
				//>if vec[n]多于 N位数-->进位
				int 大于后进位 = 0;
				switch (数字N) {
				default:
					大于后进位 = 1;
					//N位数的 最大值+1
					for (size_t i = 0; i < 数字N; i++) {
						大于后进位 *= 10;
					}
					break;
				case(1):
					大于后进位 = 十;
					break;
				case(2):
					大于后进位 = 一百;
					break;
				case(3):
					大于后进位 = 一千;
					break;
				case(4):
					大于后进位 = 一万;
					break;
				case(5):
					大于后进位 = 十万;
					break;
				case(6):
					大于后进位 = 百万;
					break;
				case(7):
					大于后进位 = 千万;
					break;
				case(8):
					大于后进位 = 一亿;
					break;
				}
				//>if vec[n]多于 N位数-->进位
				if (vec[N位数序号] >= 大于后进位) {
					//更新 N位个数
					if (N位个数 <= N位数序号 - 1) { //限定 \ 只运行一次
						N位个数 = N位数序号; //记录位数
						N位个数_有数值 = N位数序号 + 1;
					}
					while (vec[N位数序号] >= 大于后进位) { //>限制在N位数 \ 超过N位数就进位
						vec[N位数序号] = vec[N位数序号] - 大于后进位;
						/// 2023年6月10日 15:00
						//? 这句怎么没啦?
						vec[N位数序号 + 1] += 1;
						///cout << "n位置是 " << vec[N位数序号]; //n是序号
						///cout << '\n';
						///cout << "左边是 " << vec[N位数序号 + 1];
						///cout << '\n';
					}
				}
			}
		}
		vecdatap = nullptr; vecp = nullptr;
	}
	//coutN位数 \ 只读取
	auto coutN位数(vector<类型>& vec, 类型 N位数序号) { //>N位数= N位数的内容 \ N位个数= 有几个N位数
		if (N位个数_有数值 >= N位数序号) {
			cout << vec[N位数序号] << ",";
		}
	}
	//▬1▬零件 \ 输出str▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	string 补充0(string 结果, vector<类型>& vec, 类型 N位数序号) { //>如果是n位数, 显示N-n个0
		类型* vecdatap = vec.data(); vector< 类型>* vecp = &vec;
		//>左边有数字, 中间+0
		类型 N位数序号位置上的位数n = ret整数位数(vec[N位数序号]);
		//左边的N位数有数字, 才需要+0
		if (N位个数 >= N位数序号
			&& N位数序号 < vec.size()) {
			类型 _0的个数 = 数字N - N位数序号位置上的位数n;
			if (_0的个数 >= 0
				&& _0的个数 <= 数字N) { //case(负数): 会一直循环 
				//输出'0'
				for (size_t i = 0; i < _0的个数; i++) {
					结果.append("0");
				}
			}
		}
		vecdatap = nullptr; vecp = nullptr;
		return 结果;
	}
	类型 retN位数(vector<类型>& vec, 类型 N位数序号) { ///2023年8月13日03:26:28 函数不见了, 重写了
		if (N位个数_有数值 >= N位数序号) {
			return vec[N位数序号];
		}
	}
	string retN位数(string 结果, vector<类型>& vec, 类型 N位数序号) { //>N位数= N位数的内容 \ N位个数= 有几个N位数
		if (N位个数_有数值 >= N位数序号) {
			结果.append(to_string(vec[N位数序号])); 结果.append(",");
		}
		return 结果;
	}
	//▬2▬零件 \ vec的数N分▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	/*输出`完整的v; 不是分开, 会进位的*/
	auto 进位再cout(vector<类型>& vec) {
		//!进位	从右往左 
		//!显示	从左往右 \ 是否有数字->补充0->显示数字->右边的N位数 
		类型* vecdatap = vec.data(); vector< 类型>* vecp = &vec;
		N位个数初始化(vec);
		序号_第一个n = 1;
		//*x..............................................................................
		//>进位	从小往大
		for (size_t i = 序号_第一个n; i < 14; i++) {
			进位(vec, i);
		}
		/*没更新*/
		N位个数初始化(vec);
		//*x..............................................................................
		//>显示	从大往小 \ 是否有数字->补充0->显示数字->右边的N位数 
		for (size_t i = N位个数_有数值; i > 序号_第一个n; i--) {
			补充0(vec, i);
			couta2(
				retN位数(vec, i),
				",");
		}
		补充0(vec, 1);
		cout << vec[1];
		vecdatap = nullptr; vecp = nullptr;
	}
	/*暴力解决*/
	auto 进位再cout(vector<类型>& vec, int N位个数_有数值) {
		//!进位	从右往左 
		//!显示	从左往右 \ 是否有数字->补充0->显示数字->右边的N位数 
		类型* vecdatap = vec.data(); vector< 类型>* vecp = &vec;
		序号_第一个n = 1;
		//*..............................................................................
		//>进位	从小往大
		for (size_t i = 序号_第一个n; i < 14; i++) {
			进位(vec, i);
		}
		//*x..............................................................................
		//>显示	从大往小 \ 是否有数字->补充0->显示数字->右边的N位数 
		for (size_t i = N位个数_有数值; i > 序号_第一个n; i--) {
			补充0(vec, i);
			couta2(
				retN位数(vec, i),
				",");
		}
		补充0(vec, 1);
		cout << vec[1];
		vecdatap = nullptr; vecp = nullptr;
	}
	/*功能闭环了,下面都是附加的*/
	auto 进位再返回str(string& 结果str, vector<类型>& vec) { //> 改变原vec
		//!进位	从右往左 
		//!显示	从左往右 \ 是否有数字->补充0->显示数字->右边的N位数 
		类型* vecdatap = vec.data(); vector< 类型>* vecp = &vec;
		N位个数初始化(vec);
		序号_第一个n = 1;
		//*x..............................................................................
		//>进位	从小往大
		for (size_t i = 序号_第一个n; i < 14; i++) {
			进位(vec, i);
		}
		//*x..............................................................................
		//>显示	从大往小 \ 是否有数字->补充0->显示数字->右边的N位数 
		for (size_t i = N位个数_有数值; i > 序号_第一个n; i--) {
			结果str = 补充0(结果str, vec, i);
			结果str = retN位数(结果str, vec, i);
		}
		//补充0 \ 第一个N位数 append0
		结果str = 补充0(结果str, vec, 1);
		//append 第1个N位数
		结果str.append(to_string(vec[1]));
		vecdatap = nullptr; vecp = nullptr;
	}
	///2023年6月12日 03:27:54
	//?编译器错误 \ ;->:了
	auto 进位再返回str(vector<类型>& vec) {
		string 结果str;
		进位再返回str(结果str, vec);
		return 结果str;
	}
	/**///!▬附加功能▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬ ▬▬▬▬▬▬▬▬▬▬▬▬▬▬ 
	//>N \ 实现 \ 直接用, 从这里用, 用法, 应该分开的
	//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	//>cmd里cout \ 输入一个数字 \ 输出一个数字
	//> 数字-->cout数字
	//把uu转换为 带,的形式
	void cout计数(int uu) { //用class里定义的vector<类型>计数
		计数.assign(2, 0);
		cout数字(计数, uu);
		///2023年6月10日 20:18
		//TODO assign(47 输出的数字位数不够, 像提前结束. \ assign(2 结果错误 \ assign(3 outofrange \ assign(4 一样
	}

	/*cout数字(vec, uu)*/
	void cout数字(类型 uu)	{
		///	2023年6月10日 00:08:24
		//?	函数里定义的vec在函数里的函数里不能修改, 返回vec没用, vec != 返回的vec \
			返回值也有错误, ','左边永远是0 \ 已解决, 有一句被删了
		///	2023年6月10日21:21:05
		//	TODO vector subscript out of range
		vector<类型>  vec;
		初始化();
		vec.assign(2, 0);
		cout数字(vec, uu);
	}
	//不明确
	//void cout数字(类型 &uu){
	//	vector<类型>  vec;
	//	初始化();
	//	vec.assign(2, 0);
	//	cout数字(vec, uu);
	//}
	/**/
	void cout数字(vector<类型>& vec, 类型 uu) {
		初始化();
		vec[1] = uu;
		进位再cout(vec);
	}
	/**///>cout; vector-->cout数字
	auto coutvec(vector<类型>& vec) { //> 
		//不初始化
		进位再cout(vec);
	}
	auto cVTO数字(vector<类型>& vec) { 
		coutvec(vec);
	}
	/**///>输入一个数字 \ 返回str
	string ret数字str(vector<类型>& vec, 类型 uu) { //> 数字-->str
		string 结果str;
		//=====================================
		vec[1] = uu;
		进位再返回str(结果str, vec);
		return 结果str;
	}
	string ret数字str(类型 uu) {
		string 结果str;
		vector<类型>  vec;
		初始化();
		vec.assign(2, 0);
		//=====================================
		结果str = ret数字str(vec, uu);
		return 结果str;
	}
	//>输入`vector, 输出`str
	string ret数字str(vector<类型>& vec) { //> vec-->str
		string 结果str;
		vec.assign(2, 0);
		初始化();
		进位再返回str(结果str, vec);
		return 结果str;
	}
	/**///▬例子▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
	void 用法(vector<类型>& vec, 类型 uu) {
		初始化();
		vec[1] = uu;
		进位再cout(vec);
	}
};
//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
/**/
//▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬




//
/**///▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬▬
//



#endif